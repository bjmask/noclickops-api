<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>NoClickOps Network</title>
  <link rel="stylesheet" href="/static/style.css">
  <script src="/static/nav.js"></script>
  <style>
    .filter-group { display:flex; flex-direction:column; gap:6px; position:relative; min-width:220px; }
    .filter-label { color:var(--text-muted); font-size:12px; }
    .filter-trigger { display:flex; align-items:center; gap:8px; padding:8px 12px; border:1px solid var(--border); border-radius:6px; background:rgba(255,255,255,0.04); cursor:pointer; }
    .filter-trigger input { background:transparent; border:none; color:var(--text-main); width:100%; outline:none; cursor:pointer; }
    .caret { color:var(--text-muted); font-size:0.9rem; }
    .filter-dropdown { display:none; position:absolute; top:calc(100% + 6px); right:0; z-index:30; min-width:200px; max-height:260px; border:1px solid var(--border); border-radius:8px; background:rgba(15,18,25,0.98); box-shadow:0 10px 30px rgba(0,0,0,0.35); padding:8px; box-sizing:border-box; }
    .filter-options { max-height:200px; overflow-y:auto; display:flex; flex-direction:column; gap:4px; }
    .filter-option { display:flex; align-items:center; justify-content:space-between; padding:6px 10px; border-radius:4px; cursor:pointer; }
    .filter-option:hover { background:rgba(255,255,255,0.05); }
    .filter-option.selected { background:rgba(255,255,255,0.08); }
    .filter-option.highlighted { background:rgba(100,149,237,0.3) !important; }
    .filter-option span { white-space:normal; }
    .filter-check { width:16px; text-align:right; visibility:hidden; }
    .filter-option.selected .filter-check { visibility:visible; }
    .th-wrap { display:flex; align-items:center; justify-content:space-between; gap:6px; }
    .th-actions { display:flex; align-items:center; gap:6px; }
    .sort-icon, .filter-icon { cursor:pointer; color:var(--text-muted); font-size:12px; }
    .filter-icon { transform:rotate(180deg); } /* inverted caret */
    th { position:relative; }
  </style>
</head>

<body>
  <div class="layout-dashboard">
    <aside>
      <div id="nav-container"></div>
      <div style="margin-top:auto;">
        <button id="logout-btn" class="btn btn-secondary" style="width:100%;">Logout</button>
      </div>
    </aside>

    <main>
      <div class="page-header">
        <div>
          <h1 class="page-title">Network</h1>
          <p class="page-desc" id="network-meta">Loading network flows...</p>
        </div>
      </div>

      <div class="card" style="margin-bottom:12px; display:flex; gap:8px; align-items:center; padding:12px;">
        <button id="prev-page" class="btn btn-secondary" style="min-width:64px;">Prev</button>
        <div id="page-info" style="flex:1; text-align:center;">Page 1</div>
        <button id="next-page" class="btn btn-secondary" style="min-width:64px;">Next</button>
        <div style="margin-left:auto; display:flex; align-items:center; gap:6px;">
          <label for="collapse-mode" style="font-size:12px; color:var(--text-muted);">Collapse</label>
          <select id="collapse-mode" class="input" style="width:120px;">
            <option value="pod" selected>Pod</option>
            <option value="owner">Owner</option>
            <option value="ip">IP</option>
            <option value="none">None</option>
          </select>
          <label for="per-page" style="font-size:12px; color:var(--text-muted); margin-left:10px;">Per page</label>
          <label for="per-page" style="font-size:12px; color:var(--text-muted);">Per page</label>
          <select id="per-page" class="input" style="width:80px;">
            <option value="25">25</option>
            <option value="50" selected>50</option>
            <option value="100">100</option>
            <option value="200">200</option>
            <option value="200">1000</option>
          </select>
        </div>
      </div>
      <div class="card" style="margin-bottom:12px; padding:10px; display:flex; gap:12px; flex-wrap:wrap; align-items:center; position:relative;">
        <div class="filter-group">
          <span class="filter-label">Columns</span>
          <div class="filter-trigger" id="col-trigger">
            <input id="col-input" placeholder="Select columns" readonly autocomplete="off" />
            <span class="caret">⌄</span>
          </div>
          <div id="col-dropdown" class="filter-dropdown" onclick="event.stopPropagation();">
            <div id="col-options" class="filter-options"></div>
          </div>
        </div>
      </div>

      <div class="card" style="padding:0;overflow:hidden;">
        <div class="table-container" style="border:none;border-radius:0;">
          <table id="network-table" style="width:100%; table-layout: fixed;">
            <thead>
              <tr>
                <th class="col-src" data-sort="src" data-filter="src"><div class="th-wrap"><span>Source</span><div class="th-actions"><span class="sort-icon">↕</span><span class="filter-icon">⌃</span></div></div></th>
                <th class="col-dst" data-sort="dst" data-filter="dst"><div class="th-wrap"><span>Destination</span><div class="th-actions"><span class="sort-icon">↕</span><span class="filter-icon">⌃</span></div></div></th>
                <th class="col-src-pod" data-sort="src_pod" data-filter="src_pod"><div class="th-wrap"><span>Source Pod</span><div class="th-actions"><span class="sort-icon">↕</span><span class="filter-icon">⌃</span></div></div></th>
                <th class="col-dst-pod" data-sort="dst_pod" data-filter="dst_pod"><div class="th-wrap"><span>Destination Pod</span><div class="th-actions"><span class="sort-icon">↕</span><span class="filter-icon">⌃</span></div></div></th>
                <th class="col-src-ns" data-sort="src_ns" data-filter="src_ns"><div class="th-wrap"><span>Source Namespace</span><div class="th-actions"><span class="sort-icon">↕</span><span class="filter-icon">⌃</span></div></div></th>
                <th class="col-dst-ns" data-sort="dst_ns" data-filter="dst_ns"><div class="th-wrap"><span>Destination Namespace</span><div class="th-actions"><span class="sort-icon">↕</span><span class="filter-icon">⌃</span></div></div></th>
                <th class="col-src-owner" data-sort="src_owner" data-filter="src_owner"><div class="th-wrap"><span>Source Owner</span><div class="th-actions"><span class="sort-icon">↕</span><span class="filter-icon">⌃</span></div></div></th>
                <th class="col-dst-owner" data-sort="dst_owner" data-filter="dst_owner"><div class="th-wrap"><span>Destination Owner</span><div class="th-actions"><span class="sort-icon">↕</span><span class="filter-icon">⌃</span></div></div></th>
                <th class="col-src-node" data-sort="src_node" data-filter="src_node"><div class="th-wrap"><span>Source Node</span><div class="th-actions"><span class="sort-icon">↕</span><span class="filter-icon">⌃</span></div></div></th>
                <th class="col-dst-node" data-sort="dst_node" data-filter="dst_node"><div class="th-wrap"><span>Destination Node</span><div class="th-actions"><span class="sort-icon">↕</span><span class="filter-icon">⌃</span></div></div></th>
                <th class="col-proto" data-sort="proto" data-filter="proto"><div class="th-wrap"><span>Proto</span><div class="th-actions"><span class="sort-icon">↕</span><span class="filter-icon">⌃</span></div></div></th>
                <th data-sort="dst_port" data-filter="dst_port" class="col-port"><div class="th-wrap"><span>Destination Port</span><div class="th-actions"><span class="sort-icon">↕</span><span class="filter-icon">⌃</span></div></div></th>
                <th data-sort="http" data-filter="http" class="col-http"><div class="th-wrap"><span>HTTP Endpoint</span><div class="th-actions"><span class="sort-icon">↕</span><span class="filter-icon">⌃</span></div></div></th>
                <th data-sort="packets_ab" class="col-packets"><div class="th-wrap"><span>Packets A→B</span><div class="th-actions"><span class="sort-icon">↕</span></div></div></th>
                <th data-sort="packets_ba" class="col-packets"><div class="th-wrap"><span>Packets B→A</span><div class="th-actions"><span class="sort-icon">↕</span></div></div></th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
      </div>

      <div class="error" id="err" style="display:none;color:var(--accent-danger);margin-top:20px;"></div>
    </main>
  </div>

  <script>
    // Compact lookup for common ports; extend as needed.
    const PORT_LABELS = {
      20: "FTP-data",
      21: "FTP",
      22: "SSH/SFTP",
      23: "Telnet",
      25: "SMTP",
      53: "DNS",
      80: "HTTP",
      110: "POP3",
      123: "NTP",
      143: "IMAP",
      161: "SNMP",
      162: "SNMP trap",
      389: "LDAP",
      443: "HTTPS",
      465: "SMTPS",
      514: "Syslog",
      587: "Submission (SMTP)",
      631: "IPP/Printing",
      873: "rsync",
      993: "IMAPS",
      995: "POP3S",
      1080: "SOCKS",
      1433: "MSSQL",
      1521: "Oracle",
      2049: "NFS",
      2181: "ZooKeeper",
      2379: "etcd client",
      2380: "etcd peer",
      3000: "HTTP-alt / Node / Grafana",
      3306: "MySQL",
      3389: "RDP",
      4443: "HTTPS-alt / K8s API alt",
      4567: "Galera",
      5000: "Container registry / HTTP-alt",
      5432: "PostgreSQL",
      5601: "Kibana",
      5671: "AMQP TLS",
      5672: "AMQP / RabbitMQ",
      5900: "VNC",
      5985: "WinRM HTTP",
      5986: "WinRM HTTPS",
      6000: "X11",
      6379: "Redis",
      7000: "Cassandra",
      7001: "Cassandra",
      7002: "Cassandra",
      7199: "JMX (Cassandra)",
      8000: "HTTP-alt",
      8080: "HTTP-alt",
      8081: "HTTP-alt",
      8443: "HTTPS-alt / K8s API alt",
      8500: "Consul",
      9000: "Minio/SonarQube",
      9090: "Prometheus",
      9092: "Kafka",
      9100: "node_exporter",
      9200: "Elasticsearch",
      9300: "Elasticsearch internal",
      9443: "HTTPS-alt",
      9999: "Misc service",
      11211: "Memcached",
      15672: "RabbitMQ UI",
      27017: "MongoDB"
    };
    const PROTO_NAMES = {
      6: "TCP",
      17: "UDP",
    };

    mountNav('network');

    let token = localStorage.getItem("noclickops_token") || "";
    let currentPage = 1;
    let perPage = Number(localStorage.getItem("network_per_page") || "50");
    let collapseMode = localStorage.getItem("network_collapse") || "pod";
    let featureFlags = {
      packet_counts: false,
      http_endpoint: false,
      dst_port: false,
    };
    let columnToggles = (() => {
      try {
        return JSON.parse(localStorage.getItem("network_cols") || "{}");
      } catch (_) {
        return {};
      }
    })();
    const defaultColumns = {
      src: true,
      dst: true,
      src_pod: true,
      dst_pod: true,
      src_ns: true,
      dst_ns: true,
      src_owner: true,
      dst_owner: true,
      src_node: true,
      dst_node: true,
      proto: true,
      dst_port: true,
      http: true,
      packets: true,
    };
    columnToggles = { ...defaultColumns, ...columnToggles };
    const err = document.getElementById("err");
    const logoutBtn = document.getElementById("logout-btn");
    const meta = document.getElementById("network-meta");
    const tbody = document.querySelector("#network-table tbody");
    const prevBtn = document.getElementById("prev-page");
    const nextBtn = document.getElementById("next-page");
    const pageInfo = document.getElementById("page-info");
    const perPageSelect = document.getElementById("per-page");
    const collapseSelect = document.getElementById("collapse-mode");
    const colTrigger = document.getElementById("col-trigger");
    const colDropdown = document.getElementById("col-dropdown");
    const colOptions = document.getElementById("col-options");
    const colInput = document.getElementById("col-input");
    perPageSelect.value = String(perPage);
    collapseSelect.value = collapseMode;
    let columnOptions = [
      { key: "src", label: "Source" },
      { key: "dst", label: "Destination" },
      { key: "src_pod", label: "Source Pod" },
      { key: "dst_pod", label: "Destination Pod" },
      { key: "src_ns", label: "Source Namespace" },
      { key: "dst_ns", label: "Destination Namespace" },
      { key: "src_owner", label: "Source Owner" },
      { key: "dst_owner", label: "Destination Owner" },
      { key: "src_node", label: "Source Node" },
      { key: "dst_node", label: "Destination Node" },
      { key: "proto", label: "Proto" },
      { key: "dst_port", label: "Destination Port" },
      { key: "http", label: "HTTP Endpoint" },
      { key: "packets", label: "Packets A→B / B→A" },
    ];
    const FILTER_FIELDS = [
      { key: "src", label: "Source" },
      { key: "dst", label: "Destination" },
      { key: "src_pod", label: "Source Pod" },
      { key: "dst_pod", label: "Destination Pod" },
      { key: "src_ns", label: "Source Namespace" },
      { key: "dst_ns", label: "Destination Namespace" },
      { key: "src_owner", label: "Source Owner" },
      { key: "dst_owner", label: "Destination Owner" },
      { key: "src_node", label: "Source Node" },
      { key: "dst_node", label: "Destination Node" },
      { key: "proto", label: "Proto" },
      { key: "dst_port", label: "Destination Port" },
      { key: "http", label: "HTTP Endpoint" },
    ];
    const filterState = {};
    FILTER_FIELDS.forEach(f => {
      filterState[f.key] = { options: [], selected: new Set() };
    });
    let currentRows = [];
    let sortKey = "server"; // honor server ordering by default
    let sortDir = -1; // descending

    function api(path, opts = {}) {
      const headers = opts.headers || {};
      headers["Content-Type"] = "application/json";
      if (token) headers["Authorization"] = "Bearer " + token;
      return fetch(path, { ...opts, headers }).then(async res => {
        const data = await res.json().catch(() => ({}));
        if (res.status === 401) {
          redirectToLogin();
          throw "unauthorized";
        }
        if (!res.ok) throw data.error || res.statusText;
        return data;
      });
    }

    function redirectToLogin() {
      localStorage.removeItem("noclickops_token");
      window.location.href = "/";
    }

    function showError(message) {
      err.style.display = "block";
      err.textContent = message;
    }

    function clearError() {
      err.style.display = "none";
    }

    function setupSort() {
      document.querySelectorAll("#network-table .sort-icon").forEach(icon => {
        if (icon.dataset.bound) return;
        icon.dataset.bound = "1";
        icon.addEventListener("click", (e) => {
          e.stopPropagation();
          const th = icon.closest("th");
          const key = th?.getAttribute("data-sort");
          if (!key) return;
          if (sortKey === key) {
            sortDir = -sortDir;
          } else {
            sortKey = key;
            sortDir = -1;
          }
          render(currentRows, meta.getAttribute("data-total") ? Number(meta.getAttribute("data-total")) : currentRows.length);
        });
      });
    }

    function portLabel(port) {
      if (!port || Number.isNaN(port)) return "";
      if (port >= 30000 && port <= 32767) return `K8s NodePort (${port})`;
      if (port >= 32768) return `Ephemeral port (${port})`;
      return PORT_LABELS[port] || "";
    }

    function sortedRows(rows) {
      if (sortKey === "server") return rows;
      return [...rows].sort((a, b) => {
        const av = sortKey === "packets" ? (Number(a.packets_ab || 0) + Number(a.packets_ba || 0)) : a[sortKey];
        const bv = sortKey === "packets" ? (Number(b.packets_ab || 0) + Number(b.packets_ba || 0)) : b[sortKey];
        let cmp = 0;
        if (typeof av === "number" && typeof bv === "number") {
          cmp = av === bv ? 0 : (av < bv ? -1 : 1);
        } else {
          const as = (av || "").toString().toLowerCase();
          const bs = (bv || "").toString().toLowerCase();
          cmp = as === bs ? 0 : (as < bs ? -1 : 1);
        }
        return cmp * sortDir;
      });
    }

    function render(rows, totalCount) {
      const displayRows = sortedRows(rows);
      const showHttp = !!featureFlags.http_endpoint;
      const showPackets = !!featureFlags.packet_counts;
      if (!rows.length) {
        tbody.innerHTML = `<tr><td colspan="7" class="text-center text-muted" style="padding:32px;">No network flows yet.</td></tr>`;
        meta.textContent = "0 flows";
        pageInfo.textContent = `Page ${currentPage}`;
        prevBtn.disabled = true;
        nextBtn.disabled = true;
        return;
      }
      tbody.innerHTML = displayRows.map(r => `
        <tr>
          <td class="col-src">${r.src || "-"}</td>
          <td class="col-dst">${r.dst || "-"}</td>
          <td class="col-src-pod">${r.src_pod || "-"}</td>
          <td class="col-dst-pod">${r.dst_pod || "-"}</td>
          <td class="col-src-ns">${r.src_ns || "-"}</td>
          <td class="col-dst-ns">${r.dst_ns || "-"}</td>
          <td class="col-src-owner">${r.src_owner || "-"}</td>
          <td class="col-dst-owner">${r.dst_owner || "-"}</td>
          <td class="col-src-node">${r.src_node || "-"}</td>
          <td class="col-dst-node">${r.dst_node || "-"}</td>
          <td class="col-proto">${r.proto || "-"}</td>
          <td class="col-port" title="${r.dst_port_label || ""}">${r.dst_port ?? "-"}</td>
          ${showHttp ? `<td class="col-http" title="${r.http_endpoint || ""}">${r.http_endpoint || "-"}</td>` : ""}
          ${showPackets ? `<td class="col-packets">${r.packets_ab}</td>` : ""}
          ${showPackets ? `<td class="col-packets">${r.packets_ba}</td>` : ""}
        </tr>
      `).join("");
      meta.textContent = `${rows.length} flow(s) on this page — total ${totalCount}`;
      const totalPages = Math.max(1, Math.ceil(totalCount / perPage));
      pageInfo.textContent = `Page ${currentPage} of ${totalPages}`;
      prevBtn.disabled = currentPage <= 1;
      nextBtn.disabled = currentPage >= totalPages;
      applyColumnVisibility();
    }

    function parseEndpointLabel(label) {
      const parts = (label || "").split(":");
      if (parts[0] === "pod") {
        return { pod: parts[2] || "", ns: parts[1] || "", node: "" };
      }
      if (parts[0] === "node") {
        return { pod: "", ns: "", node: parts[2] || parts[1] || "" };
      }
      return { pod: "", ns: "", node: "", raw: label || "" };
    }

    function applyColumnVisibility() {
      const colMap = {
        "col-src-pod": columnToggles.src_pod,
        "col-dst-pod": columnToggles.dst_pod,
        "col-src-ns": columnToggles.src_ns,
        "col-dst-ns": columnToggles.dst_ns,
        "col-src": columnToggles.src,
        "col-dst": columnToggles.dst,
        "col-src-owner": columnToggles.src_owner,
        "col-dst-owner": columnToggles.dst_owner,
        "col-src-node": columnToggles.src_node,
        "col-dst-node": columnToggles.dst_node,
        "col-proto": columnToggles.proto,
        "col-port": columnToggles.dst_port && featureFlags.dst_port,
        "col-http": columnToggles.http && featureFlags.http_endpoint,
        "col-packets": columnToggles.packets && featureFlags.packet_counts,
      };
      Object.entries(colMap).forEach(([cls, visible]) => {
        document.querySelectorAll("." + cls).forEach(el => {
          el.style.display = visible ? "" : "none";
        });
      });
    }

    async function loadSchema() {
      try {
        const schema = await api("/v1/network/schema");
        if (schema && schema.features) {
          featureFlags = {
            packet_counts: !!schema.features.packet_counts?.enabled,
            http_endpoint: !!schema.features.http_endpoint?.enabled,
            dst_port: !!schema.features.dst_port?.enabled,
          };
        }
      } catch (e) {
        // keep defaults if schema fetch fails
        console.warn("failed to load schema", e);
      }
      columnOptions = [
        { key: "src", label: "Source" },
        { key: "dst", label: "Destination" },
        { key: "src_pod", label: "Source Pod" },
        { key: "dst_pod", label: "Destination Pod" },
        { key: "src_ns", label: "Source Namespace" },
        { key: "dst_ns", label: "Destination Namespace" },
        { key: "src_owner", label: "Source Owner" },
        { key: "dst_owner", label: "Destination Owner" },
        { key: "src_node", label: "Source Node" },
        { key: "dst_node", label: "Destination Node" },
        { key: "proto", label: "Proto" },
      ];
      if (featureFlags.dst_port) columnOptions.push({ key: "dst_port", label: "Destination Port" });
      if (featureFlags.http_endpoint) columnOptions.push({ key: "http", label: "HTTP Endpoint" });
      if (featureFlags.packet_counts) {
        columnOptions.push({ key: "packets", label: "Packets A→B / B→A" });
      }
      columnOptions.forEach(opt => {
        if (columnToggles[opt.key] === undefined) {
          columnToggles[opt.key] = true;
        }
      });
      renderColumnOptions();
      applyColumnVisibility();
    }

    function buildQueryParams() {
      const params = new URLSearchParams();
      params.set("hide_src_port", "true");
      params.set("page", String(currentPage));
      params.set("per_page", String(perPage));
      params.set("collapse", collapseMode);
      FILTER_FIELDS.forEach(f => {
        const selected = Array.from(filterState[f.key].selected);
        if (selected.length) {
          params.set(f.key, selected.join(","));
        }
      });
      return params.toString();
    }

    async function loadKeys() {
      try {
        const qs = new URLSearchParams();
        qs.set("hide_src_port", "true");
        qs.set("collapse", collapseMode);
        const data = await api(`/v1/network/keys?${qs.toString()}`);
        // If the backend returns port keys but the schema was missing the feature flag,
        // enable the column/filter so users can actually see and filter by port.
        if (!featureFlags.dst_port && data && Array.isArray(data.dst_port) && data.dst_port.length) {
          featureFlags.dst_port = true;
          if (!columnOptions.some(o => o.key === "dst_port")) {
            columnOptions.push({ key: "dst_port", label: "Destination Port" });
          }
          renderColumnOptions();
          applyColumnVisibility();
        }
        FILTER_FIELDS.forEach(f => {
          if (data && Array.isArray(data[f.key])) {
            filterState[f.key].options = data[f.key];
            renderFilterOptions(f.key);
          }
        });
      } catch (e) {
        console.warn("failed to load keys", e);
      }
    }

    async function loadNetwork() {
      if (!token) return redirectToLogin();
      try {
        clearError();
        const findings = await api(`/v1/network/findings?${buildQueryParams()}`);
        const items = Array.isArray(findings) ? findings : findings.items || [];
        const total = findings.total ?? items.length;
        const rows = items.map(f => {
          const sInfo = parseEndpointLabel(f.s);
          const tInfo = parseEndpointLabel(f.t);
          const dstPort = (f.dst_port && f.dst_port !== 0 ? f.dst_port : "");
          const portNum = dstPort ? Number(dstPort) : 0;
          const httpEndpoint = (f.http_path_ab && (f.http_host_ab ? `${f.http_host_ab}${f.http_path_ab}` : f.http_path_ab))
            || (f.http_path_ba && (f.http_host_ba ? `${f.http_host_ba}${f.http_path_ba}` : f.http_path_ba))
            || "";
          const cleanOwner = (o) => (o || "").replace(/^o:/, "");
          const srcCombined = sInfo.pod ? `${sInfo.ns ? sInfo.ns + ":" : ""}${sInfo.pod}` : (sInfo.raw || f.s || "");
          const dstCombined = tInfo.pod ? `${tInfo.ns ? tInfo.ns + ":" : ""}${tInfo.pod}` : (tInfo.raw || f.t || "");
          return {
            src: srcCombined,
            dst: dstCombined,
            src_pod: sInfo.pod || sInfo.raw || "",
            dst_pod: tInfo.pod || tInfo.raw || "",
            src_ns: sInfo.ns || "",
            dst_ns: tInfo.ns || "",
            src_owner: cleanOwner(f.o_s),
            dst_owner: cleanOwner(f.o_t),
            src_node: sInfo.node || "",
            dst_node: tInfo.node || "",
            proto: f.l7_a || f.l7_b || PROTO_NAMES[f.proto] || f.proto || "",
            dst_port: dstPort,
            dst_port_label: portLabel(portNum),
            http_endpoint: httpEndpoint,
            http: httpEndpoint,
            packets_ab: Number(f.packets_ab ?? 0),
            packets_ba: Number(f.packets_ba ?? 0),
            packets: Number(f.packets_ab || 0) + Number(f.packets_ba || 0),
          };
        });
        currentRows = rows;
        meta.setAttribute("data-total", String(total));
        render(rows, total);
      } catch (e) {
        showError(e);
      }
    }

    logoutBtn.addEventListener("click", redirectToLogin);
    prevBtn.addEventListener("click", () => {
      if (currentPage > 1) {
        currentPage -= 1;
        loadNetwork();
      }
    });
    nextBtn.addEventListener("click", () => {
      currentPage += 1;
      loadNetwork();
    });
    perPageSelect.addEventListener("change", () => {
      perPage = Number(perPageSelect.value);
      localStorage.setItem("network_per_page", String(perPage));
      currentPage = 1;
      loadNetwork();
    });
    collapseSelect.addEventListener("change", () => {
      collapseMode = collapseSelect.value;
      localStorage.setItem("network_collapse", collapseMode);
      currentPage = 1;
      loadKeys().then(() => loadNetwork());
    });

    function persistColumnToggles() {
      localStorage.setItem("network_cols", JSON.stringify(columnToggles));
      applyColumnVisibility();
    }

    function renderColumnOptions() {
      colOptions.innerHTML = "";
      columnOptions.forEach(opt => {
        const div = document.createElement("div");
        div.className = "filter-option" + (columnToggles[opt.key] ? " selected" : "");
        div.setAttribute("data-key", opt.key);
        div.innerHTML = `<span>${opt.label}</span><span class="filter-check">✓</span>`;
        div.addEventListener("click", () => {
          columnToggles[opt.key] = !columnToggles[opt.key];
          renderColumnOptions();
          persistColumnToggles();
        });
        colOptions.appendChild(div);
      });
      updateColInput();
    }

    function updateColInput() {
      const active = columnOptions.filter(o => columnToggles[o.key]).map(o => o.label);
      colInput.value = active.length ? active.join(", ") : "Select columns";
    }

    function toggleColDropdown() {
      const show = colDropdown.style.display !== "block";
      colDropdown.style.display = show ? "block" : "none";
    }

    colTrigger.addEventListener("click", (e) => {
      e.stopPropagation();
      toggleColDropdown();
    });

    document.addEventListener("click", (e) => {
      if (!colDropdown.contains(e.target) && e.target !== colTrigger) {
        colDropdown.style.display = "none";
      }
      if (!e.target.closest(".filter-dropdown") && !e.target.classList.contains("filter-icon")) {
        closeAllFilterDropdowns();
      }
    });

    function closeAllFilterDropdowns() {
      document.querySelectorAll(".filter-dropdown").forEach(dd => dd.style.display = "none");
    }
    
    function handleSearchKeydown(e, filterKey) {
      const optionsContainer = document.getElementById(`filter-options-${filterKey}`);
      if (!optionsContainer) return;
      
      const visibleOptions = Array.from(optionsContainer.querySelectorAll('.filter-option'))
        .filter(opt => opt.style.display !== 'none');
      
      if (visibleOptions.length === 0) return;
      
      // Handle Cmd+Space or Ctrl+Space to apply selected filters
      if ((e.metaKey || e.ctrlKey) && e.code === 'Space') {
        e.preventDefault();
        closeAllFilterDropdowns();
        loadNetwork();
        return;
      }
      
      let currentIndex = parseInt(optionsContainer.dataset.highlightedIndex || '-1');
      
      switch (e.key) {
        case 'ArrowDown':
          e.preventDefault();
          currentIndex = (currentIndex + 1) % visibleOptions.length;
          highlightOption(visibleOptions, currentIndex, optionsContainer);
          break;
          
        case 'ArrowUp':
          e.preventDefault();
          currentIndex = currentIndex <= 0 ? visibleOptions.length - 1 : currentIndex - 1;
          highlightOption(visibleOptions, currentIndex, optionsContainer);
          break;
          
        case 'Enter':
          e.preventDefault();
          if (currentIndex >= 0 && currentIndex < visibleOptions.length) {
            visibleOptions[currentIndex].click();
          }
          break;
          
        case 'Escape':
          e.preventDefault();
          closeAllFilterDropdowns();
          break;
      }
    }
    
    function highlightOption(visibleOptions, index, container) {
      // Remove previous highlight
      removeHighlight(container);
      
      if (index >= 0 && index < visibleOptions.length) {
        const option = visibleOptions[index];
        option.classList.add('highlighted');
        option.style.background = 'rgba(100,149,237,0.3)'; // Cornflower blue highlight
        
        // Scroll into view if needed
        option.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
        
        container.dataset.highlightedIndex = index;
      }
    }
    
    function removeHighlight(container) {
      const filterKey = container.id.replace('filter-options-', '');
      container.querySelectorAll('.filter-option.highlighted').forEach(opt => {
        opt.classList.remove('highlighted');
        const optionText = opt.textContent.replace('✓', '').trim();
        const state = filterState[filterKey];
        if (state) {
          opt.style.background = state.selected.has(optionText) ? 'rgba(255,255,255,0.08)' : '';
        }
      });
    }

    function updateFilterInputText(kind) {
      const input = document.getElementById(`filter-input-${kind}`);
      if (!input) return;
      const sel = Array.from(filterState[kind].selected);
      input.value = sel.length ? sel.join(", ") : "Select";
    }

    function renderFilterOptions(kind) {
      const state = filterState[kind];
      const container = document.getElementById(`filter-options-${kind}`);
      if (!container) return;
      container.innerHTML = "";
      state.options.forEach(opt => {
        const div = document.createElement("div");
        div.className = "filter-option" + (state.selected.has(opt) ? " selected" : "");
        div.innerHTML = `<span>${opt}</span><span class="filter-check">✓</span>`;
        div.addEventListener("click", (ev) => {
          ev.stopPropagation();
          if (state.selected.has(opt)) {
            state.selected.delete(opt);
          } else {
            state.selected.add(opt);
          }
          renderFilterOptions(kind);
          updateFilterInputText(kind);
          loadNetwork();
        });
        container.appendChild(div);
      });
      updateFilterInputText(kind);
    }

    function filterFilterOptions(kind) {
      const searchInput = document.getElementById(`filter-search-${kind}`);
      const opts = document.getElementById(`filter-options-${kind}`);
      if (!searchInput || !opts) return;
      
      const term = searchInput.value;
      let regex = null;
      let useRegex = false;
      
      // Try to parse as regex
      if (term.length > 0) {
        try {
          regex = new RegExp(term, 'i');
          useRegex = true;
        } catch (e) {
          // If regex parsing fails, fall back to simple string matching
          useRegex = false;
        }
      }
      
      const options = opts.querySelectorAll(".filter-option");
      options.forEach((opt, index) => {
        const txt = opt.textContent.replace('✓', '').trim();
        let matches = false;
        
        if (!term) {
          matches = true;
        } else if (useRegex && regex) {
          matches = regex.test(txt);
        } else {
          matches = txt.toLowerCase().includes(term.toLowerCase());
        }
        
        opt.style.display = matches ? "flex" : "none";
        opt.dataset.optionIndex = index;
      });
      
      // Reset highlighted index when filter changes
      delete opts.dataset.highlightedIndex;
      removeHighlight(opts);
    }

    function toggleFilterDropdown(kind) {
      const dd = document.getElementById(`filter-dd-${kind}`);
      if (!dd) return;
      const show = dd.style.display !== "block";
      closeAllFilterDropdowns();
      dd.style.display = show ? "block" : "none";
      if (show) {
        const search = document.getElementById(`filter-search-${kind}`);
        if (search) {
          search.value = "";
          filterFilterOptions(kind);
          search.focus();
        }
      }
    }

    function buildHeaderFilters() {
      FILTER_FIELDS.forEach(f => {
        const th = document.querySelector(`th[data-filter="${f.key}"]`);
        if (!th) return;
        const icon = th.querySelector(".filter-icon");
        if (icon && !icon.dataset.bound) {
          icon.dataset.bound = "1";
          icon.addEventListener("click", (e) => {
            e.stopPropagation();
            toggleFilterDropdown(f.key);
          });
        }
        if (!document.getElementById(`filter-dd-${f.key}`)) {
          const dd = document.createElement("div");
          dd.id = `filter-dd-${f.key}`;
          dd.className = "filter-dropdown";
          dd.onclick = (ev) => ev.stopPropagation();
          dd.innerHTML = `
            <input id="filter-search-${f.key}" class="filter-search" placeholder="Search (supports regex)..." oninput="filterFilterOptions('${f.key}')" autocomplete="off" />
            <div id="filter-options-${f.key}" class="filter-options"></div>
          `;
          th.appendChild(dd);
          
          // Add keyboard handler after the element is added to DOM
          setTimeout(() => {
            const searchInput = document.getElementById(`filter-search-${f.key}`);
            if (searchInput) {
              searchInput.addEventListener('keydown', (e) => handleSearchKeydown(e, f.key));
            }
          }, 0);
        }
      });
    }

    buildHeaderFilters();
    renderColumnOptions();
    applyColumnVisibility();
    setupSort();
    loadSchema().then(() => {
      buildHeaderFilters();
      return loadKeys().then(() => loadNetwork());
    });
    setInterval(loadNetwork, 10000);
    setInterval(loadKeys, 30000);
  </script>
</body>

</html>
